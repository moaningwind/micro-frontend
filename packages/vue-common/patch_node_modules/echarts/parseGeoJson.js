/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * AUTO-GENERATED FILE. DO NOT MODIFY.
 */

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

/**
 * Parse and decode geo json
 */
import * as zrUtil from 'zrender/lib/core/util'
import { GeoJSONRegion } from './Region'

function decode(json) {
  if (!json.UTF8Encoding)
    return json

  let encodeScale = json.UTF8Scale
  if (encodeScale == null)
    encodeScale = 1024

  const features = json.features

  for (let f = 0; f < features.length; f++) {
    const feature = features[f]
    const geometry = feature.geometry
    const coordinates = geometry.coordinates
    const encodeOffsets = geometry.encodeOffsets

    for (let c = 0; c < coordinates.length; c++) {
      const coordinate = coordinates[c]

      if (geometry.type === 'Polygon') {
        coordinates[c] = decodePolygon(coordinate, encodeOffsets[c], encodeScale)
      }
      else if (geometry.type === 'MultiPolygon') {
        for (let c2 = 0; c2 < coordinate.length; c2++) {
          const polygon = coordinate[c2]
          coordinate[c2] = decodePolygon(polygon, encodeOffsets[c][c2], encodeScale)
        }
      }
    }
  }
  // Has been decoded
  json.UTF8Encoding = false
  return json
}

function decodePolygon(coordinate, encodeOffsets, encodeScale) {
  const result = []
  let prevX = encodeOffsets[0]
  let prevY = encodeOffsets[1]

  for (let i = 0; i < coordinate.length; i += 2) {
    let x = coordinate.charCodeAt(i) - 64
    let y = coordinate.charCodeAt(i + 1) - 64
    // ZigZag decoding
    x = (x >> 1) ^ -(x & 1)
    y = (y >> 1) ^ -(y & 1)
    // Delta deocding
    x += prevX
    y += prevY

    prevX = x
    prevY = y
    // Dequantize
    result.push([x / encodeScale, y / encodeScale])
  }

  return result
}

/**
 * @alias module:echarts/coord/geo/parseGeoJson
 * @param {Object} geoJson
 * @return {module:zrender/container/Group}
 */
export default function (geoJson) {
  decode(geoJson)

  return zrUtil.map(
    zrUtil.filter(geoJson.features, (featureObj) => {
      // Output of mapshaper may have geometry null
      return (
        featureObj.geometry
        && featureObj.properties
        // avoid length error if missing coordinates
        && ((featureObj.geometry.coordinates && featureObj.geometry.coordinates.length > 0)
          // allow GeometryCollection
          || (featureObj.geometry.geometries && featureObj.geometry.geometries.length > 0))
      )
    }),
    (featureObj) => {
      const properties = featureObj.properties
      const geo = featureObj.geometry

      const coordinates = geo.coordinates

      const geometries = []
      if (geo.type === 'Polygon') {
        geometries.push({
          type: 'polygon',
          // According to the GeoJSON specification.
          // First must be exterior, and the rest are all interior(holes).
          exterior: coordinates[0],
          interiors: coordinates.slice(1),
        })
      }
      else if (geo.type === 'MultiPolygon') {
        zrUtil.each(coordinates, (item) => {
          if (item[0]) {
            geometries.push({
              type: 'polygon',
              exterior: item[0],
              interiors: item.slice(1),
            })
          }
        })
      }
      else if (geo.type === 'GeometryCollection') {
        const geometries2 = geo.geometries
        zrUtil.each(geometries2, (geo) => {
          const coordinates = geo.coordinates
          if (geo.type === 'Polygon') {
            // this is a full copy from above
            geometries.push({
              type: 'polygon',
              exterior: coordinates[0],
              interiors: coordinates.slice(1),
            })
          } // end full copy
        })
      }

      const region = new GeoJSONRegion(properties.name, geometries, properties.cp)
      region.properties = properties
      return region
    },
  )
}
